#
# This file is part of LiteX.
#
# Copyright (c) 2022 Sebastien BOUCHE <sebastien.bouche@gmail.com>
# SPDX-License-Identifier: BSD-2-Clause

import os
import sys
import re
from shutil import which, rmtree

from litex.build import tools
from litex.build.xilinx import common

# Script -------------------------------------------------------------------------------------------

def _build_script(build_name):
    if sys.platform in ["win32", "cygwin"]:
        script_contents = "REM Autogenerated by LiteX / git: " + tools.get_litex_git_revision() + "\n"
        script_contents += "vivado -mode batch -source " + build_name + ".tcl\n"
        script_file = "build_" + build_name + ".bat"
        tools.write_to_file(script_file, script_contents)
    else:
        script_contents = "# Autogenerated by LiteX / git: " + tools.get_litex_git_revision() + "\nset -e\n"
        if os.getenv("LITEX_ENV_VIVADO", False):
            script_contents += "source " + os.path.join(os.getenv("LITEX_ENV_VIVADO"), "settings64.sh\n")
        script_contents += "vivado -mode batch -source " + build_name + ".tcl\n"
        script_file = "build_" + build_name + ".sh"
        tools.write_to_file(script_file, script_contents)
    return script_file

def _run_script(script):
    if sys.platform in ["win32", "cygwin"]:
        shell = ["cmd", "/c"]
    else:
        shell = ["bash"]

    if which("vivado") is None and os.getenv("LITEX_ENV_VIVADO", False) == False:
        msg = "Unable to find or source Vivado toolchain, please either:\n"
        msg += "- Source Vivado's settings manually.\n"
        msg += "- Or set LITEX_ENV_VIVADO environment variant to Vivado's settings path.\n"
        msg += "- Or add Vivado toolchain to your $PATH."
        raise OSError(msg)

    if tools.subprocess_call_filtered(shell + [script], common.colors) != 0:
        raise OSError("Error occured during Vivado's script execution.")

# TCL procedure definition ----------------------------------------------------------------------------

_proc_define_interface = """
proc proc_define_interface { name } {
  
  ipx::create_abstraction_definition Enjoy-Digital.com interface ${name}_rtl 1.0
  ipx::create_bus_definition Enjoy-Digital.com interface $name 1.0

  set_property xml_file_name ${name}_rtl.xml [ipx::current_busabs]
  set_property xml_file_name ${name}.xml [ipx::current_busdef]
  set_property bus_type_vlnv Enjoy-Digital.com:interface:${name}:1.0 [ipx::current_busabs]

  ipx::save_abstraction_definition [ipx::current_busabs]
  ipx::save_bus_definition [ipx::current_busdef]

}
"""

_proc_define_interface_port = """
proc proc_define_interface_port {name width dir {type none}} {

  ipx::add_bus_abstraction_port $name [ipx::current_busabs]
  set m_intf [ipx::get_bus_abstraction_ports $name -of_objects [ipx::current_busabs]]
  set_property master_presence required $m_intf
  set_property slave_presence  required $m_intf
  set_property master_width $width $m_intf
  set_property slave_width  $width $m_intf

  set m_dir "in"
  set s_dir "out"
  if {$dir eq "output"} {
    set m_dir "out"
    set s_dir "in"
  }

  set_property master_direction $m_dir $m_intf
  set_property slave_direction  $s_dir $m_intf

  if {$type ne "none"} {
    set_property is_${type} true $m_intf
  }

  ipx::save_bus_definition [ipx::current_busdef]
  ipx::save_abstraction_definition [ipx::current_busabs]
}
"""

_proc_set_version = """
proc proc_set_version { {ip_name "ip_tbd"}   \
                        {version_number "1.0"}  \
                        {core_revision_number "0"}  \
                        {display_name "display TBD"}  \
                        {description "description TBD"}  \
                        {vendor_name "Enjoy-Digital"}   \
                        {company_url "http://www.enjoy-digital.fr/"}  \
  } {
  # Management of version/revision
  set_property version $version_number [ipx::current_core]
  set_property core_revision  $core_revision_number [ipx::current_core]
  set_property display_name $display_name [ipx::current_core]
  set_property description $description [ipx::current_core]

  set_property name $ip_name [ipx::current_core]
  set_property vendor_display_name $vendor_name [ipx::current_core]
  set_property company_url $company_url [ipx::current_core]

}
"""

_proc_set_device_family = """
proc proc_set_device_family { {setting "all"} } {
  # Management of supported families
  if { $setting eq "all" } {
      set i_families ""
      foreach i_part [get_parts] {
        lappend i_families [get_property FAMILY $i_part]
      }
      set i_families [lsort -unique $i_families]
      set s_families [get_property supported_families [ipx::current_core]]
      foreach i_family $i_families {
        set s_families "$s_families $i_family Production"
        set s_families "$s_families $i_family Beta"
      }
  } else {
    set s_families $setting
  }
  set_property supported_families $s_families [ipx::current_core]
  puts "got $s_families.\n"
}
"""

_proc_archive_ip = """
proc proc_archive_ip { vendor_name ip_name {version_number "1.0"} } {
  # Management of archiving of the IP
  set archive_name "./"
  append archive_name $vendor_name "_" $ip_name "_" $version_number ".zip"
  ipx::archive_core $archive_name [ipx::current_core]
}
"""

_proc_declare_interrupt = """
proc proc_declare_interrupt { irq_name } {
  # declaration of the interrupt
  ipx::infer_bus_interface $irq_name xilinx.com:signal:interrupt_rtl:1.0 [ipx::current_core]
}
"""

_proc_add_bus_clock = """
proc proc_add_bus_clock {clock_signal_name bus_inf_name {reset_signal_name ""} {reset_signal_mode "slave"}} {
  set bus_inf_name_clean [string map {":" "_"} $bus_inf_name]
  set clock_inf_name [format "%s%s" $bus_inf_name_clean "_signal_clock"]
  set clock_inf [ipx::add_bus_interface $clock_inf_name [ipx::current_core]]
  set_property abstraction_type_vlnv "xilinx.com:signal:clock_rtl:1.0" $clock_inf
  set_property bus_type_vlnv "xilinx.com:signal:clock:1.0" $clock_inf
  set_property display_name $clock_inf_name $clock_inf
  set clock_map [ipx::add_port_map "CLK" $clock_inf]
  set_property physical_name $clock_signal_name $clock_map

  set assoc_busif [ipx::add_bus_parameter "ASSOCIATED_BUSIF" $clock_inf]
  set_property value $bus_inf_name $assoc_busif

  if { $reset_signal_name != "" } {
    set assoc_reset [ipx::add_bus_parameter "ASSOCIATED_RESET" $clock_inf]
    set_property value $reset_signal_name $assoc_reset

    set reset_inf_name [format "%s%s" $bus_inf_name_clean "_signal_reset"]
    set reset_inf [ipx::add_bus_interface $reset_inf_name [ipx::current_core]]
    set_property abstraction_type_vlnv "xilinx.com:signal:reset_rtl:1.0" $reset_inf
    set_property bus_type_vlnv "xilinx.com:signal:reset:1.0" $reset_inf
    set_property display_name $reset_inf_name $reset_inf
    set_property interface_mode $reset_signal_mode $reset_inf
    set reset_map [ipx::add_port_map "RST" $reset_inf]
    set_property physical_name $reset_signal_name $reset_map

    set reset_polarity [ipx::add_bus_parameter "POLARITY" $reset_inf]
    if {[string match {*[Nn]} $reset_signal_name] == 1} {
      set_property value "ACTIVE_LOW" $reset_polarity
    } else {
      set_property value "ACTIVE_HIGH" $reset_polarity
    }
  }
}
"""

_proc_add_bus = """
# Add a new port map definition to a bus interface.
proc proc_add_port_map {bus phys logic} {
  set map [ipx::add_port_map $phys $bus]
  set_property "PHYSICAL_NAME" $phys $map
  set_property "LOGICAL_NAME" $logic $map
}

proc proc_add_bus {bus_name mode abs_type bus_type port_maps} {
  set bus [ipx::add_bus_interface $bus_name [ipx::current_core]]

  set_property "ABSTRACTION_TYPE_VLNV" $abs_type $bus
  set_property "BUS_TYPE_VLNV" $bus_type $bus
  set_property "INTERFACE_MODE" $mode $bus

  foreach port_map $port_maps {
    proc_add_port_map $bus {*}$port_map
  }
}

"""

_proc_add_ip_files = """
proc proc_add_ip_files {ip_name ip_files} {
  set proj_fileset [get_filesets sources_1]
  foreach m_file $ip_files {
    puts "got the following file to add: $m_file.\n"
    if {[file extension $m_file] eq ".xdc"} {
      add_files -copy_to ./src -norecurse -fileset constrs_1 $m_file
    } else {
      add_files -copy_to ./src -norecurse -fileset $proj_fileset $m_file
    }
  }
  set_property "top" "$ip_name" $proj_fileset
}
"""

# XilinxVivadoToolchain ----------------------------------------------------------------------------

class XilinxVivadoIpPackaging:

    def __init__(self):
        self.version_number     = "1.0"
        self.device_family      = "all"
        self.taxonomy           = "Enjoy_Digital"
        self.vendor             = "Enjoy-Digital.com"
        self.clock_domain       = dict()
        self.custom_interface   = dict()
        self.declare_interface  = dict()
        self.generic_parameters = dict()
        self.gui_description    = dict()
        self.file_list          = list()
        self.interrupt          = None

    def _build_gui(self):

        # If dictionary is not empty 
        if (self.gui_description):
            string = '# Set GUI properties\n'
            #Parse keys to retrieve the group names.
            for group in self.gui_description:
                string1 =  'ipgui::add_group -name {'+group+'} -component [ipx::current_core] '
                string1 += '-parent [ipgui::get_pagespec -name "Page 0" '
                string1 += '-component [ipx::current_core] ] -display_name {'+group+'} -layout {vertical}\n'
                string += string1 
            #Parse vars to retrieve the generic names & order.
            for group in self.gui_description:
                vari = self.gui_description[group]['vars']
                for var in vari:
                    string2 =  'ipgui::move_param -component [ipx::current_core] '
                    string2 += '-order '+str(vari[var]['order'])+' [ipgui::get_guiparamspec -name "'+var+'" '
                    string2 += '-component [ipx::current_core]] -parent [ipgui::get_groupspec '
                    string2 += '-name "'+group+'" -component [ipx::current_core]]\n'
                    string2 += 'set_property enablement_value false [ipx::get_user_parameters '+var+' -of_objects [ipx::current_core]]\n'

                    string += string2
            return(string)
        else:
            return('# No GUI properties set.\n')

    def _build_clocks(self):

        # If dictionary is not empty 
        if (self.clock_domain):
            string = '# Set interface clock & reset properties\n'
            #Parse keys to retrieve the group names.
            for group in self.clock_domain:
                string += 'proc_add_bus_clock "'+self.clock_domain[group]['clock_domain']+'" "'+self.clock_domain[group]['interfaces']+'" "'+self.clock_domain[group]['reset']+'"\n'
            return(string)
        else:
            return('# No interface clocks properties set.\n')

    def _build_interface(self):

        # If dictionary is not empty 
        if (self.custom_interface):
            string = '# Set custom interface properties\n'
            for inf in self.custom_interface:
                string += 'proc_add_bus "'+self.custom_interface[inf]['name']+'" "'+self.custom_interface[inf]['type']+'" \\\n'
                string += '\t"'+self.vendor+':interface:'+inf+'_rtl:1.0" \\\n'
                string += '\t"'+self.vendor+':interface:'+inf+':1.0" \\\n'
                string += '\t{ \\\n'
                for signal in self.custom_interface[inf]['signals']:    
                    string += '\t\t{"'+signal+'" "'+self.custom_interface[inf]['signals'][signal]+'"} \\\n'
                string += '\t}\n'
            return(string)
        else:
            return('# No custom interface to instanciate.\n')

    def _declare_interface(self):
        if (self.declare_interface):
            project = "interfaces"
            # shutil.rmtree(project, ignore_errors=True)
            os.makedirs(project, exist_ok=True)

            for inf in self.declare_interface:
                # Prepare Vivado's tcl interface build script
                tcl = []
                # Declare Procedures
                tcl.append(_proc_define_interface)
                tcl.append(_proc_define_interface_port)
                tcl.append("set if_name {}".format(inf))
                # declare the interface name
                tcl.append("proc_define_interface $if_name")
                # declare the interface ports
                for signal in self.declare_interface[inf]['signals']:
                    tcl.append("proc_define_interface_port {} {} {} ".format(signal[0],signal[1],signal[2]))
 
                tools.write_to_file(project + "/"+inf+".tcl", "\n".join(tcl))

                # Run Vivado's tcl core packager script
                os.system("cd {} && vivado -mode batch -source {}.tcl".format(project, inf))

    # Last file of the ip_files list must be the top level file.
    def _ip_files(self, ip_files):
        string = "[list"
        for item in ip_files:
            string += " \""+item+"\""
        string += "]"
        return(string)


    # Verilog Post Processing --------------------------------------------------------------------------
    def _netlist_post_processing(self, infile):
        Found = False
        backup = infile+".old"
        os.system("cp {} {}".format(infile, backup))
        with open(backup, 'r') as reader:
            #print ("Name of the file: ", reader.name)
            inline = reader.readlines()

        with open(infile, 'w') as writer:
            #print ("Name of the file: ", writer.name)
            for line in inline:
                writer.write(line)
                m = re.search("^\);\n", line)
                if m and not Found:
                    for gen in self.generic_parameters:
                        writer.write("parameter {} = {};\n".format(gen[0],gen[1]))
                    Found = True

    # XDC Post Processing --------------------------------------------------------------------------
    def _constraints_post_processing(self, infile):
        Found = False
        backup = infile+".old"
        os.system("cp {} {}".format(infile, backup))
        with open(backup, 'r') as reader:
            #print ("Name of the file: ", reader.name)
            inline = reader.readlines()

        with open(infile, 'w') as writer:
            #print ("Name of the file: ", writer.name)
            for line in inline:
                m = re.search("Design constraints", line)
                if m:
                    Found = True
                if Found:
                    writer.write(line)

    def _build_tcl(self, platform, build_name, 
        toochain="vivadoippackaging",
        enable_wishbone=False, 
        enable_axistream=False):
        # IP Packaging is dedicted to Vivado.
        assert toochain in ["vivadoippackaging"]
        tcl = []

        # Declare TCL Procedures
        tcl.append(_proc_add_ip_files)
        tcl.append(_proc_add_bus)
        tcl.append(_proc_add_bus_clock)
        tcl.append(_proc_declare_interrupt)
        tcl.append(_proc_set_version)
        tcl.append(_proc_set_device_family)
        tcl.append(_proc_archive_ip)
        
        # Create project
        tcl.append("create_project -force -name {}_packager".format(build_name))

        #Add files
        tcl.append("proc_add_ip_files \"{}\"  \"{}\" ".format(build_name, self._ip_files(self.file_list)))

        tcl.append("ipx::package_project -root_dir . -vendor {} -library user -taxonomy /{}".format(self.vendor, self.taxonomy))
        tcl.append("set_property name {} [ipx::current_core]".format(build_name))
        
        # Set the device family compatibility
        tcl.append("proc_set_device_family \"{}\"".format(self.device_family))

        # Save the settings.
        tcl.append("ipx::save_core [ipx::current_core]\n")

        # Declare custom interfaces
        tcl.append(self._build_interface())

        # Tie interfaces and clock domains
        tcl.append(self._build_clocks())
        
        if self.interrupt is not None:
            tcl.append("proc_declare_interrupt \"{}\"\n".format(self.interrupt))
        
        tcl.append(self._build_gui())
        
        tcl.append("proc_set_version \"{}\"  \"{}\" \"{}\" \"{}\"".format("AXIConverter", self.version_number, "0", "axi_converter IP (Packaging Proof of Concept)"))
        
        # Wrap-up
        tcl.append("ipx::create_xgui_files [ipx::current_core]")
        tcl.append("ipx::update_checksums [ipx::current_core]")
        tcl.append("ipx::check_integrity -quiet [ipx::current_core]")
        tcl.append("ipx::save_core [ipx::current_core]")
        tcl.append("proc_archive_ip \"{}\" \"{}\" \"{}\"".format(self.vendor, build_name, self.version_number))
        tcl.append("close_project")
        tcl.append("\n# End\n")
        tcl.append("exit")
        tools.write_to_file("packager.tcl", "\n".join(tcl))

    def package(self, platform, file_list,
        build_dir          = "package",
        build_name         = "ip_top",
        run                = True,
        clock_domain       = dict(),
        generic_parameters = dict(),
        gui_description    = dict(),
        custom_interface   = dict(),
        declare_interface  = dict(),
        interrupt          = None,
        **kwargs):

        self.file_list          = file_list
        self.clock_domain       = clock_domain
        self.generic_parameters = generic_parameters
        self.gui_description    = gui_description
        self.custom_interface   = custom_interface
        self.declare_interface  = declare_interface
        self.interrupt          = interrupt

        # Create build directory
        rmtree(build_dir, ignore_errors=True)
        os.makedirs(build_dir, exist_ok=True)
        cwd = os.getcwd()
        
        # Process core files prior packaging
        self._netlist_post_processing("build/{}.v".format(build_name))
        self._constraints_post_processing("build/{}.xdc".format(build_name))

        os.chdir(build_dir)

        # Check if a custom interface is declared
        self._declare_interface()

        # Generate design project (.tcl)
        self._build_tcl(
            platform   = platform,
            build_name = build_name
        )


        # Run
        if run:
            script = _build_script("packager")
            _run_script(script)

        os.chdir(cwd)
