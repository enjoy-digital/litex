#
# This file is part of LiteX (Adapted from Migen for LiteX usage).
#
# This file is Copyright (c) 2013-2014 Sebastien Bourdeauducq <sb@m-labs.hk>
# This file is Copyright (c) 2013-2023 Florent Kermarrec <florent@enjoy-digital.fr>
# This file is Copyright (c) 2013-2017 Robert Jordens <jordens@gmail.com>
# This file is Copyright (c) 2016-2018 whitequark <whitequark@whitequark.org>
# This file is Copyright (c) 2017 Adam Greig <adam@adamgreig.com>
# This file is Copyright (c) 2016 Ben Reynwar <ben@reynwar.net>
# This file is Copyright (c) 2018 David Craven <david@craven.ch>
# This file is Copyright (c) 2015 Guy Hutchison <ghutchis@gmail.com>
# This file is Copyright (c) 2013 Nina Engelhardt <nina.engelhardt@omnium-gatherum.de>
# This file is Copyright (c) 2018 Robin Ole Heinemann <robin.ole.heinemann@t-online.de>
# SPDX-License-Identifier: BSD-2-Clause

import time
import datetime
import collections

from enum import IntEnum
from operator import itemgetter

from migen.fhdl.structure   import *
from migen.fhdl.structure   import _Operator, _Slice, _Assign, _Fragment
from migen.fhdl.tools       import *
from migen.fhdl.tools       import _apply_lowerer, _Lowerer
from migen.fhdl.conv_output import ConvOutput
from migen.fhdl.specials    import Instance, Memory

from litex.gen import LiteXContext
from litex.gen.fhdl.expression import _generate_expression, _generate_signal
from litex.gen.fhdl.namer      import build_signal_namespace
from litex.gen.fhdl.hierarchy  import LiteXHierarchyExplorer

from litex.build.tools import get_litex_git_revision

# ------------------------------------------------------------------------------------------------ #
#                                     BANNER/TRAILER/SEPARATORS                                    #
# ------------------------------------------------------------------------------------------------ #

_tab = " "*4

def _generate_banner(filename, device):
    return """\
// -----------------------------------------------------------------------------
// Auto-Generated by:        __   _ __      _  __
//                          / /  (_) /____ | |/_/
//                         / /__/ / __/ -_)>  <
//                        /____/_/\\__/\\__/_/|_|
//                     Build your hardware, easily!
//                   https://github.com/enjoy-digital/litex
//
// Filename   : {filename}.v
// Device     : {device}
// LiteX sha1 : {revision}
// Date       : {date}
//------------------------------------------------------------------------------\n
""".format(
    device   = device,
    filename = filename,
    revision = get_litex_git_revision(),
    date     = datetime.datetime.fromtimestamp(time.time()).strftime("%Y-%m-%d %H:%M:%S")
)

def _generate_trailer():
    return """
// -----------------------------------------------------------------------------
//  Auto-Generated by LiteX on {date}.
//------------------------------------------------------------------------------
""".format(
    date=datetime.datetime.fromtimestamp(time.time()).strftime("%Y-%m-%d %H:%M:%S")
)

def _generate_separator(msg=""):
    r =  "\n"
    r +=  "//" + "-"*78 + "\n"
    r += f"// {msg}\n"
    r +=  "//" + "-"*78 + "\n"
    r += "\n"
    return r

# ------------------------------------------------------------------------------------------------ #
#                                         TIMESCALE                                                #
# ------------------------------------------------------------------------------------------------ #

def _generate_timescale(time_unit="1ns", time_precision="1ps"):
    r = f"`timescale {time_unit} / {time_precision}\n"
    return r

# ------------------------------------------------------------------------------------------------ #
#                                         HIERARCHY                                                #
# ------------------------------------------------------------------------------------------------ #

def _generate_hierarchy(top):
    if top is None:
        return ""
    else:
        hierarchy_explorer = LiteXHierarchyExplorer(top=top, depth=None, with_colors=False)
        r = "/*\n"
        for l in hierarchy_explorer.get_hierarchy().split("\n"):
            r += l + "\n"
        r = r[:-1]
        r += "*/\n"
        return r

# ------------------------------------------------------------------------------------------------ #
#                                    RESERVED KEYWORDS                                             #
# ------------------------------------------------------------------------------------------------ #

_ieee_1800_2017_verilog_reserved_keywords = {
     "accept_on",          "alias",          "always",         "always_comb",          "always_ff",
  "always_latch",            "and",          "assert",              "assign",             "assume",
     "automatic",         "before",           "begin",                "bind",               "bins",
        "binsof",            "bit",           "break",                 "buf",             "bufif0",
        "bufif1",           "byte",            "case",               "casex",              "casez",
          "cell",        "chandle",         "checker",               "class",           "clocking",
          "cmos",         "config",           "const",          "constraint",            "context",
      "continue",          "cover",      "covergroup",          "coverpoint",              "cross",
      "deassign",        "default",        "defparam",              "design",            "disable",
          "dist",             "do",            "edge",                "else",                "end",
       "endcase",     "endchecker",        "endclass",         "endclocking",          "endconfig",
   "endfunction",    "endgenerate",        "endgroup",        "endinterface",          "endmodule",
    "endpackage",   "endprimitive",      "endprogram",         "endproperty",        "endsequence",
    "endspecify",       "endtable",         "endtask",                "enum",              "event",
    "eventually",         "expect",          "export",             "extends",             "extern",
         "final",    "first_match",             "for",               "force",            "foreach",
       "forever",           "fork",        "forkjoin",            "function",           "generate",
        "genvar",         "global",          "highz0",              "highz1",                 "if",
           "iff",         "ifnone",     "ignore_bins",        "illegal_bins",         "implements",
       "implies",         "import",          "incdir",             "include",            "initial",
         "inout",          "input",          "inside",            "instance",                "int",
       "integer",   "interconnect",       "interface",           "intersect",               "join",
      "join_any",      "join_none",           "large",                 "let",            "liblist",
       "library",          "local",      "localparam",               "logic",            "longint",
   "macromodule",        "matches",          "medium",             "modport",             "module",
          "nand",        "negedge",         "nettype",                 "new",           "nexttime",
          "nmos",            "nor", "noshowcancelled",                 "not",             "notif0",
        "notif1",           "null",              "or",              "output",            "package",
        "packed",      "parameter",            "pmos",             "posedge",          "primitive",
      "priority",        "program",        "property",           "protected",              "pull0",
         "pull1",       "pulldown",          "pullup", "pulsestyle_ondetect", "pulsestyle_onevent",
          "pure",           "rand",           "randc",            "randcase",       "randsequence",
         "rcmos",           "real",        "realtime",                 "ref",                "reg",
     "reject_on",        "release",    "      repeat",            "restrict",             "return",
         "rnmos",          "rpmos",           "rtran",            "rtranif0",           "rtranif1",
      "s_always",   "s_eventually",      "s_nexttime",             "s_until",       "s_until_with",
      "scalared",       "sequence",        "shortint",           "shortreal",      "showcancelled",
        "signed",          "small",            "soft",               "solve",            "specify",
     "specparam",         "static",          "string",              "strong",            "strong0",
       "strong1",         "struct",           "super",             "supply0",            "supply1",
"sync_accept_on", "sync_reject_on",           "table",              "tagged",               "task",
          "this",     "throughout",            "time",       "timeprecision",           "timeunit",
          "tran",        "tranif0",         "tranif1",                 "tri",               "tri0",
          "tri1",         "triand",           "trior",              "trireg",               "type",
       "typedef",   "       union",          "unique",             "unique0",           "unsigned",
         "until",     "until_with",         "untyped",                 "use",           "   uwire",
           "var",       "vectored",         "virtual",                "void",               "wait",
    "wait_order",           "wand",            "weak",               "weak0",              "weak1",
         "while",       "wildcard",            "wire",                "with",             "within",
           "wor",           "xnor",             "xor",
}

# ------------------------------------------------------------------------------------------------ #
#                                          NODES                                                   #
# ------------------------------------------------------------------------------------------------ #

class AssignType(IntEnum):
    BLOCKING     = 0
    NON_BLOCKING = 1
    SIGNAL       = 2

def _generate_node(ns, at, level, node, target_filter=None):
    assert at in [item.value for item in AssignType]
    if target_filter is not None and target_filter not in list_targets(node):
        return ""

    # Assignment.
    elif isinstance(node, _Assign):
        if at == AssignType.BLOCKING:
            assignment = " = "
        elif at == AssignType.NON_BLOCKING:
            assignment = " <= "
        elif is_variable(node.l):
            assignment = " = "
        else:
            assignment = " <= "
        return _tab*level + _generate_expression(ns, node.l)[0] + assignment + _generate_expression(ns, node.r)[0] + ";\n"

    # Iterable.
    elif isinstance(node, collections.abc.Iterable):
        return "".join(_generate_node(ns, at, level, n, target_filter) for n in node)

    # If.
    elif isinstance(node, If):
        r = _tab*level + "if (" + _generate_expression(ns, node.cond)[0] + ") begin\n"
        r += _generate_node(ns, at, level + 1, node.t, target_filter)
        if node.f:
            r += _tab*level + "end else begin\n"
            r += _generate_node(ns, at, level + 1, node.f, target_filter)
        r += _tab*level + "end\n"
        return r

    # Case.
    elif isinstance(node, Case):
        if node.cases:
            r = _tab*level + "case (" + _generate_expression(ns, node.test)[0] + ")\n"
            css = [(k, v) for k, v in node.cases.items() if isinstance(k, Constant)]
            css = sorted(css, key=lambda x: x[0].value)
            for choice, statements in css:
                r += _tab*(level + 1) + _generate_expression(ns, choice)[0] + ": begin\n"
                r += _generate_node(ns, at, level + 2, statements, target_filter)
                r += _tab*(level + 1) + "end\n"
            if "default" in node.cases:
                r += _tab*(level + 1) + "default: begin\n"
                r += _generate_node(ns, at, level + 2, node.cases["default"], target_filter)
                r += _tab*(level + 1) + "end\n"
            r += _tab*level + "endcase\n"
            return r
        else:
            return ""

    # Display.
    elif isinstance(node, Display):
        s = "\"" + node.s + "\""
        for arg in node.args:
            s += ", "
            if isinstance(arg, Signal):
                s += ns.get_name(arg)
            else:
                s += str(arg)
        return _tab*level + "$display(" + s + ");\n"

    # Finish.
    elif isinstance(node, Finish):
        return _tab*level + "$finish;\n"

    # Unknown.
    else:
        raise TypeError(f"Node of unrecognized type: {str(type(node))}")

# ------------------------------------------------------------------------------------------------ #
#                                        ATTRIBUTES                                                #
# ------------------------------------------------------------------------------------------------ #

def _generate_attribute(attr, attr_translate):
    r = ""
    first = True
    for attr in sorted(attr, key=lambda x: ("", x) if isinstance(x, str) else x):
        if isinstance(attr, tuple):
            # Platform-dependent attribute.
            attr_name, attr_value = attr
        else:
            # Translated attribute.
            at = attr_translate.get(attr, None)
            if at is None:
                continue
            attr_name, attr_value = at
        if not first:
            r += ", "
        first = False
        const_expr = "\"" + attr_value + "\"" if not isinstance(attr_value, int) else str(attr_value)
        r += attr_name + " = " + const_expr
    if r:
        r = "(* " + r + " *)\n"
    return r

# ------------------------------------------------------------------------------------------------ #
#                                           MODULE                                                 #
# ------------------------------------------------------------------------------------------------ #

def _use_wire(stmts):
    return (len(stmts) == 1 and isinstance(stmts[0], _Assign) and
            not isinstance(stmts[0].l, _Slice))

def _list_comb_wires(f):
    r = set()
    groups = group_by_targets(f.comb)
    for g in groups:
        if _use_wire(g[1]):
            r |= g[0]
    return r

def _analyze_all_signal_usage(f):
    """Analyze ALL signals to determine correct wire/reg classification"""
    wire_assigned_signals = set()  # Signals only in assign statements
    proc_assigned_signals = set()  # Signals assigned in procedural blocks
    
    # Analyze all combinatorial assignments
    groups = group_by_targets(f.comb)
    for g in groups:
        if _use_wire(g[1]):
            wire_assigned_signals |= g[0]
        else:
            proc_assigned_signals |= g[0]
    
    # Analyze synchronous assignments
    for domain_stmts in f.sync.values():
        proc_assigned_signals |= list_targets(domain_stmts)
    
    return wire_assigned_signals, proc_assigned_signals

def _list_comb_regs(f):
    """Returns set of signals that need to be declared as reg because they're assigned in always blocks."""
    _, proc_assigned_signals = _analyze_all_signal_usage(f)
    return proc_assigned_signals & set(list_targets(f))

def _classify_all_signals(f, ios):
    """Classify ALL signals (both internal and output ports) based on actual usage patterns"""
    wire_signals, proc_signals = _analyze_all_signal_usage(f)
    
    # Find ALL signals that need reg treatment (both internal and output ports)
    all_signals = list_signals(f) | list_special_ios(f, ins=True, outs=True, inouts=True)
    all_proc_signals = all_signals & proc_signals  # ALL signals assigned procedurally
    
    # Separate internal vs output port signals
    output_ports = {sig for sig in ios if sig in list_targets(f)}
    output_proc_signals = output_ports & proc_signals  # Output ports needing reg treatment
    internal_proc_signals = all_proc_signals - output_ports  # Internal signals needing reg treatment
    
    return all_proc_signals, output_proc_signals, internal_proc_signals, wire_signals, proc_signals

def _pre_generate_intermediate_signals(f, ios, ns):
    """Generate ALL intermediate signals BEFORE any other code generation"""
    all_proc_signals, output_proc_signals, internal_proc_signals, wire_signals, proc_signals = _classify_all_signals(f, ios)
    
    # Store comprehensive mappings in namespace for use by ALL subsequent generation phases
    ns._reg_signal_mappings = {}
    ns._slice_wire_mappings = {}
    ns._intermediate_wires = {}
    
    # Handle output ports (need wire bridges)
    for sig in output_proc_signals:
        internal_name = ns.get_name(sig) + "_reg"
        ns._reg_signal_mappings[sig] = internal_name
        ns._intermediate_wires[sig] = {
            'reg_name': internal_name,
            'slice_wires': {}  # Will be populated as needed
        }
    
    # Handle internal signals (will be declared as reg directly, no bridge needed)
    for sig in internal_proc_signals:
        # For internal signals, namespace wrapper will redirect to same name, but we mark them for reg declaration
        ns._reg_signal_mappings[sig] = ns.get_name(sig)  # Same name, but will be declared as reg
        ns._intermediate_wires[sig] = {
            'reg_name': ns.get_name(sig),
            'slice_wires': {},
            'internal_signal': True  # Mark as internal signal
        }
    
    return all_proc_signals, output_proc_signals, internal_proc_signals

def _pre_allocate_slice_wires(ns, all_specials):
    """Pre-analyze ALL instance connections to identify needed slice wires"""
    from migen.fhdl.specials import Instance
    from migen.fhdl.structure import _Slice
    
    for special in all_specials:
        if isinstance(special, Instance):
            for io in special.items:
                if hasattr(io, 'expr') and isinstance(io.expr, _Slice):
                    base_signal = io.expr.value
                    if hasattr(ns, '_reg_signal_mappings') and base_signal in ns._reg_signal_mappings:
                        # Pre-allocate slice wire
                        slice_key = (base_signal, io.expr.start, io.expr.stop)
                        if slice_key not in ns._slice_wire_mappings:
                            wire_name = ns.get_name(base_signal) + "_out"
                            ns._slice_wire_mappings[slice_key] = {
                                'wire_name': wire_name,
                                'slice_width': io.expr.stop - io.expr.start,
                                'original_name': ns.get_name(base_signal)
                            }

def _generate_signal_declaration(sig, name):
    """Generate signal declaration with custom name."""
    if len(sig) == 1:
        return name
    else:
        return f"[{len(sig)-1}:0] {name}"

def _get_signal_name_for_assignment(ns, sig):
    """Get the appropriate signal name for assignment (use reg version if available)."""
    if hasattr(ns, '_reg_signal_mappings') and sig in ns._reg_signal_mappings:
        return ns._reg_signal_mappings[sig]
    else:
        return ns.get_name(sig)

class _NamespaceWrapper:
    """Wrapper that redirects certain signals to their reg versions."""
    def __init__(self, ns):
        self.ns = ns
        
    def get_name(self, sig):
        if hasattr(self.ns, '_reg_signal_mappings') and sig in self.ns._reg_signal_mappings:
            return self.ns._reg_signal_mappings[sig]
        else:
            return self.ns.get_name(sig)
    
    def __getattr__(self, name):
        return getattr(self.ns, name)

def _resolve_instance_expression(ns, expr):
    """Resolve instance expressions with guaranteed wire availability"""
    from migen.fhdl.structure import _Slice
    from litex.gen.fhdl.expression import _generate_expression
    
    # By this point, ALL intermediate wires are already pre-allocated
    if isinstance(expr, _Slice) and hasattr(ns, '_slice_wire_mappings'):
        slice_key = (expr.value, expr.start, expr.stop)
        if slice_key in ns._slice_wire_mappings:
            return ns._slice_wire_mappings[slice_key]['wire_name'], False
    
    # Use namespace wrapper for other cases
    return _generate_expression(_NamespaceWrapper(ns), expr)

def _generate_module(f, ios, name, ns, attr_translate):
    sigs         = list_signals(f) | list_special_ios(f, ins=True, outs=True, inouts=True)
    special_outs = list_special_ios(f, ins=False, outs=True,  inouts=True)
    inouts       = list_special_ios(f, ins=False, outs=False, inouts=True)
    targets      = list_targets(f) | special_outs
    comb_regs    = _list_comb_regs(f)
    wires        = (_list_comb_wires(f) | special_outs) - comb_regs

    r = f"module {name} (\n"
    firstp = True
    for sig in sorted(ios, key=lambda x: ns.get_name(x)):
        if not firstp:
            r += ",\n"
        firstp = False
        attr = _generate_attribute(sig.attr, attr_translate)
        if attr:
            r += _tab + attr
        sig.type = "wire"
        sig.name = ns.get_name(sig)
        sig.port = True
        if sig in inouts:
            sig.direction = "inout"
            r += _tab + "inout  wire " + _generate_signal(ns, sig)
        elif sig in targets:
            sig.direction = "output"
            sig.type = "wire"  # All output ports should be wire
            r += _tab + "output wire " + _generate_signal(ns, sig)
        else:
            sig.direction = "input"
            r += _tab + "input  wire " + _generate_signal(ns, sig)
    r += "\n);\n\n"

    return r

def _generate_all_intermediate_signals(ns, output_proc_signals, attr_translate, regs_init):
    """Generate intermediate signals for output ports only (internal signals handled separately)"""
    r = ""
    
    # Generate internal reg signals for output ports needing reg treatment (not internal signals)
    for sig in sorted(output_proc_signals, key=lambda x: ns.get_name(x)):
        # Skip internal signals - they're handled in main signal generation
        if (hasattr(ns, '_intermediate_wires') and sig in ns._intermediate_wires and 
            ns._intermediate_wires[sig].get('internal_signal', False)):
            continue
            
        r += _generate_attribute(sig.attr, attr_translate)
        internal_name = ns._reg_signal_mappings[sig]
        r += f"reg {_generate_signal_declaration(sig, internal_name)}"
        if regs_init:
            r += " = " + _generate_expression(ns, sig.reset)[0]
        r += ";\n"
    
    # Generate ALL slice wires (pre-allocated during instance analysis)
    if hasattr(ns, '_slice_wire_mappings') and ns._slice_wire_mappings:
        r += "\n// Intermediate wires for sliced instance connections\n"
        for slice_key, mapping in ns._slice_wire_mappings.items():
            wire_name = mapping['wire_name']
            slice_width = mapping['slice_width']
            
            # Generate wire declaration
            if slice_width > 1:
                r += f"wire [{slice_width-1}:0] {wire_name};\n"
            else:
                r += f"wire {wire_name};\n"
        r += "\n"
    
    # Generate assign statements for output ports only (internal signals don't need bridges)
    for sig in sorted(output_proc_signals, key=lambda x: ns.get_name(x)):
        # Skip internal signals - they don't need assign bridges
        if (hasattr(ns, '_intermediate_wires') and sig in ns._intermediate_wires and 
            ns._intermediate_wires[sig].get('internal_signal', False)):
            continue
            
        original_name = ns.get_name(sig)
        internal_name = ns._reg_signal_mappings[sig]
        r += f"assign {original_name} = {internal_name};\n"
    
    # Generate slice assign statements
    if hasattr(ns, '_slice_wire_mappings') and ns._slice_wire_mappings:
        for slice_key, mapping in ns._slice_wire_mappings.items():
            base_signal, start, stop = slice_key
            original_name = mapping['original_name']
            wire_name = mapping['wire_name']
            if stop - start > 1:
                slice_expr = f"{original_name}[{stop-1}:{start}]"
            else:
                slice_expr = f"{original_name}[{start}]"
            r += f"assign {wire_name} = {slice_expr};\n"
    
    return r

def _generate_signals(f, ios, name, ns, attr_translate, regs_init):
    sigs = list_signals(f) | list_special_ios(f, ins=True, outs=True, inouts=True)
    special_outs = list_special_ios(f, ins=False, outs=True,  inouts=True)
    inouts       = list_special_ios(f, ins=False, outs=False, inouts=True)
    targets      = list_targets(f) | special_outs
    comb_regs    = _list_comb_regs(f)
    wires        = (_list_comb_wires(f) | special_outs) - comb_regs
    
    r = ""
    
    # Generate internal signals (excluding IOs)
    for sig in sorted(sigs - ios, key=lambda x: ns.get_name(x)):
        r += _generate_attribute(sig.attr, attr_translate)
        
        # Check if this signal is marked for reg treatment (internal procedural signal)
        if (hasattr(ns, '_intermediate_wires') and sig in ns._intermediate_wires and 
            ns._intermediate_wires[sig].get('internal_signal', False)):
            # This internal signal needs reg declaration
            r += "reg  " + _generate_signal(ns, sig)
            if regs_init:
                r += " = " + _generate_expression(ns, sig.reset)[0]
            r += ";\n"
        elif sig in wires:
            r += "wire " + _generate_signal(ns, sig) + ";\n"
        else:
            r += "reg  " + _generate_signal(ns, sig)
            if regs_init:
                r += " = " + _generate_expression(ns, sig.reset)[0]
            r += ";\n"
    
    # Generate ALL intermediate signals (already pre-calculated in namespace)
    if hasattr(ns, '_reg_signal_mappings') and ns._reg_signal_mappings:
        output_proc_signals = set(ns._reg_signal_mappings.keys())
        r += _generate_all_intermediate_signals(ns, output_proc_signals, attr_translate, regs_init)
    
    return r

# ------------------------------------------------------------------------------------------------ #
#                                  COMBINATORIAL LOGIC                                             #
# ------------------------------------------------------------------------------------------------ #

def _generate_combinatorial_logic_sim(f, ns):
    r = ""
    if f.comb:
        target_stmt_map = collections.defaultdict(list)

        for statement in flat_iteration(f.comb):
            targets = list_targets(statement)
            for t in targets:
                target_stmt_map[t].append(statement)

        groups = group_by_targets(f.comb)

        for n, (t, stmts) in enumerate(target_stmt_map.items()):
            assert isinstance(t, Signal)
            if _use_wire(stmts):
                r += "assign " + _generate_node(ns, AssignType.BLOCKING, 0, stmts[0])
            else:
                r += "always @(*) begin\n"
                r += _tab + ns.get_name(t) + " <= " + _generate_expression(ns, t.reset)[0] + ";\n"
                r += _generate_node(ns, AssignType.NON_BLOCKING, 1, stmts, t)
                r += "end\n"
    r += "\n"
    return r

def _generate_combinatorial_logic_synth(f, ns):
    r = ""
    if f.comb:
        groups = group_by_targets(f.comb)

        for n, g in enumerate(groups):
            if _use_wire(g[1]):
                r += "assign " + _generate_node(ns, AssignType.BLOCKING, 0, g[1][0])
            else:
                # Use wrapper namespace for procedural assignments to redirect to reg versions
                ns_wrapper = _NamespaceWrapper(ns)
                r += "always @(*) begin\n"
                for t in sorted(g[0], key=lambda x: ns.get_name(x)):
                    signal_name = _get_signal_name_for_assignment(ns, t)
                    r += _tab + signal_name + " <= " + _generate_expression(ns_wrapper, t.reset)[0] + ";\n"
                r += _generate_node(ns_wrapper, AssignType.NON_BLOCKING, 1, g[1])
                r += "end\n"
    r += "\n"
    return r

# ------------------------------------------------------------------------------------------------ #
#                                    SYNCHRONOUS LOGIC                                             #
# ------------------------------------------------------------------------------------------------ #

def _generate_synchronous_logic(f, ns):
    r = ""
    for k, v in sorted(f.sync.items(), key=itemgetter(0)):
        r += "always @(posedge " + ns.get_name(f.clock_domains[k].clk) + ") begin\n"
        # Use namespace wrapper for consistent signal redirection
        ns_wrapper = _NamespaceWrapper(ns)
        r += _generate_node(ns_wrapper, AssignType.SIGNAL, 1, v)
        r += "end\n\n"
    return r

# ------------------------------------------------------------------------------------------------ #
#                                      SPECIALS                                                    #
# ------------------------------------------------------------------------------------------------ #

def _generate_specials(name, overrides, specials, namespace, add_data_file, attr_translate):
    r = ""
    for special in sorted(specials, key=lambda x: x.duid):
        if hasattr(special, "attr"):
            r += _generate_attribute(special.attr, attr_translate)
        # Replace Migen Memory's emit_verilog with LiteX's implementation.
        if isinstance(special, Memory):
            from litex.gen.fhdl.memory import _memory_generate_verilog
            pr = _memory_generate_verilog(name, special, namespace, add_data_file)
        # Replace Migen Instance's emit_verilog with LiteX's implementation.
        elif isinstance(special, Instance):
            from litex.gen.fhdl.instance import _instance_generate_verilog
            pr = _instance_generate_verilog(special, namespace, add_data_file)
        else:
            pr = call_special_classmethod(overrides, special, "emit_verilog", namespace, add_data_file)
        if pr is None:
            raise NotImplementedError("Special " + str(special) + " failed to implement emit_verilog")
        r += pr
    return r

# ------------------------------------------------------------------------------------------------ #
#                                       LOWERER                                                    #
# ------------------------------------------------------------------------------------------------ #

def _lower_slice_cat(node, start, length):
    while isinstance(node, Cat):
        cat_start = 0
        for e in node.l:
            if cat_start <= start < cat_start + len(e) >= start + length:
                start -= cat_start
                node = e
                break
            cat_start += len(e)
        else:
            break
    return node, start

def _lower_slice_replicate(node, start, length):
    while isinstance(node, Replicate):
        if start//len(node.v) == (start + length - 1)//len(node.v):
            start = start % len(node.v)
            node = node.v
        else:
            break
    return node, start

def _lower_slice_invert(node, inv):
    while isinstance(node, _Operator) and node.op == "~":
        node = node.operands[0]
        inv = not inv
    return node, inv

class _ComplexSliceLowerer(_Lowerer):
    def visit_Slice(self, node):
        length = len(node)
        start = 0
        inv = False
        while isinstance(node, _Slice):
            start += node.start
            node = node.value
            while True:
                node, start = _lower_slice_cat(node, start, length)
                former_node = node
                node, start = _lower_slice_replicate(node, start, length)
                node, inv   = _lower_slice_invert(node, inv)
                if node is former_node:
                    break
        if start == 0 and len(node) == length:
            pass
        elif isinstance(node, Signal):
            node = _Slice(node, start, start + length)
        else:
            slice_proxy = Signal(value_bits_sign(node))
            if self.target_context:
                a = _Assign(node, slice_proxy)
            else:
                a = _Assign(slice_proxy, node)
            self.comb.append(self.visit_Assign(a))
            node = _Slice(slice_proxy, start, start + length)
        if inv:
            node = ~node
        if isinstance(node, _Slice):
            return NodeTransformer.visit_Slice(self, node)
        else:
            return NodeTransformer.visit(self, node)

def lower_complex_slices(f):
    return _apply_lowerer(_ComplexSliceLowerer(), f)

# ------------------------------------------------------------------------------------------------ #
#                                    FHDL --> VERILOG                                              #
# ------------------------------------------------------------------------------------------------ #

class DummyAttrTranslate(dict):
    def __getitem__(self, k):
        return (k, "true")

def convert(f, ios=set(), name="top", platform=None,
    # Verilog parameters.
    special_overrides = dict(),
    attr_translate    = DummyAttrTranslate(),
    regular_comb      = True,
    regs_init         = True,
    # Sim parameters.
    time_unit      = "1ns",
    time_precision = "1ps",
    ):

    # Build Logic.
    # ------------

    # Create ConvOutput.
    r = ConvOutput()

    # Convert to FHDL's fragments is not already done.
    if not isinstance(f, _Fragment):
        f = f.get_fragment()

    # Verify/Create Clock Domains.
    for cd_name in sorted(list_clock_domains(f)):
        # Try to get Clock Domain.
        try:
            f.clock_domains[cd_name]
        # If not found, raise Error.
        except:
            msg = f"""Unresolved clock domain {cd_name}, availables:\n"""
            for f in f.clock_domains:
                msg += f"- {f.name}\n"
            raise Exception(msg)

    # Lower complex slices.
    f = lower_complex_slices(f)

    # Insert resets.
    insert_resets(f)

    # Lower basics.
    f = lower_basics(f)

    # Lower specials.
    if platform is not None:
        for s in f.specials:
            s.platform = platform
    f, lowered_specials = lower_specials(special_overrides, f)

    # Lower complex slices (for complex slices included in specials).
    f = lower_complex_slices(f)

    # Lower basics (for basics included in specials).
    f = lower_basics(f)

    # IOs collection (when not specified).
    if len(ios) == 0:
        assert platform is not None
        ios = platform.constraint_manager.get_io_signals()

    # IOs backtrace/naming.
    for io in sorted(ios, key=lambda x: x.duid):
        if io.name_override is None:
            io_name = io.backtrace[-1][0]
            if io_name:
                io.name_override = io_name

    # Build Signal Namespace.
    # ----------------------
    ns = build_signal_namespace(
        signals = (
            list_signals(f) |
            list_special_ios(f, ins=True, outs=True, inouts=True) |
            ios
        ),
        reserved_keywords = _ieee_1800_2017_verilog_reserved_keywords
    )
    ns.clock_domains = f.clock_domains

    # Pre-Generation Phase: Analyze and Pre-Allocate ALL Intermediate Signals
    # ------------------------------------------------------------------------
    all_proc_signals, output_proc_signals, internal_proc_signals = _pre_generate_intermediate_signals(f, ios, ns)
    _pre_allocate_slice_wires(ns, f.specials)

    # Build Verilog.
    # --------------
    verilog = ""

    # Banner.
    verilog += _generate_banner(
        filename = name,
        device   = getattr(platform, "device", "Unknown")
    )

    # Timescale.
    verilog += _generate_timescale(
        time_unit      = time_unit,
        time_precision = time_precision
    )

    # Module Definition.
    verilog += _generate_separator("Module")
    verilog += _generate_module(f, ios, name, ns, attr_translate)

    # Module Hierarchy.
    verilog += _generate_separator("Hierarchy")
    verilog += _generate_hierarchy(top=LiteXContext.top)

    # Module Signals.
    verilog += _generate_separator("Signals")
    verilog += _generate_signals(f, ios, name, ns, attr_translate, regs_init)

    # Combinatorial Logic.
    verilog += _generate_separator("Combinatorial Logic")
    if regular_comb:
        verilog += _generate_combinatorial_logic_synth(f, ns)
    else:
        verilog += _generate_combinatorial_logic_sim(f, ns)

    # Synchronous Logic.
    verilog += _generate_separator("Synchronous Logic")
    verilog += _generate_synchronous_logic(f, ns)

    # Specials
    verilog += _generate_separator("Specialized Logic")
    verilog += _generate_specials(
        name           = name,
        overrides      = special_overrides,
        specials       = f.specials - lowered_specials,
        namespace      = ns,
        add_data_file  = r.add_data_file,
        attr_translate = attr_translate
    )

    # Module End.
    verilog += "endmodule\n"

    # Trailer.
    verilog += _generate_trailer()

    r.set_main_source(verilog)
    r.ns = ns

    return r
